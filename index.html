<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<body
  style="
    margin: 0;
    background: #000;
    display: grid;
    place-items: center;
    height: 100dvh;
    overflow: hidden;
  "
>
  <!-- Keep the video decoding: do NOT display:none -->
  <video
    id="src"
    playsinline
    muted
    autoplay
    style="
      position: fixed;
      left: -9999px;
      top: -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
    "
  ></video>

  <canvas
    id="out"
    style="width: 100vw; height: 100vh; object-fit: cover"
  ></canvas>

  <!-- Controls -->
  <div
    id="controls"
    style="
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 12px 16px;
      background: rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(6px);
      color: #fff;
      font: 500 16px system-ui, -apple-system, Segoe UI, Roboto;
    "
  >
    <label style="display: block; margin: 0 0 6px">
      Lag rate (playback speed): <span id="rateVal">0.50×</span>
    </label>
    <input
      id="rate"
      type="range"
      min="0.20"
      max="1.00"
      step="0.05"
      value="0.50"
      style="width: 100%"
    />
  </div>

  <!-- Only shown if auto-start fails and a user gesture is required -->
  <div
    id="tapToStart"
    style="
      display: none;
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      text-align: center;
      padding: 24px;
      font: 600 18px system-ui, -apple-system, Segoe UI, Roboto;
      user-select: none;
    "
  >
    <div>
      <div style="font-size: 20px; margin-bottom: 8px">
        Tap to enable camera
      </div>
      <div style="opacity: 0.8">
        Browser blocked auto-start. One tap will grant permission.
      </div>
    </div>
  </div>
  <script>
    /*** Rear camera selection (unchanged) ***/
    async function getRearStream() {
      const base = { width: { ideal: 1920 }, height: { ideal: 1080 } };
      const gum = (extra = {}) =>
        navigator.mediaDevices.getUserMedia({
          video: { ...base, ...extra },
          audio: false,
        });

      try {
        return await gum({ facingMode: { exact: "environment" } });
      } catch {}
      try {
        return await gum({ facingMode: { ideal: "environment" } });
      } catch {}

      // Enumerate as fallback (needs prior permission on most phones)
      let tempStream = null;
      try {
        tempStream = await gum({ facingMode: { ideal: "user" } });
      } catch {}
      let devices = [];
      try {
        devices = await navigator.mediaDevices.enumerateDevices();
      } finally {
        if (tempStream) tempStream.getTracks().forEach((t) => t.stop());
      }

      const cams = devices.filter((d) => d.kind === "videoinput");
      const rearish = cams.find((d) => /back|rear|environment/i.test(d.label));
      if (rearish) {
        return await navigator.mediaDevices.getUserMedia({
          video: { deviceId: { exact: rearish.deviceId }, ...base },
          audio: false,
        });
      }
      if (cams.length > 1) {
        return await navigator.mediaDevices.getUserMedia({
          video: {
            deviceId: { exact: cams[cams.length - 1].deviceId },
            ...base,
          },
          audio: false,
        });
      }
      return await gum();
    }

    /*** App ***/
    const src = document.getElementById("src");
    const canvas = document.getElementById("out");
    const ctx = canvas.getContext("2d", { alpha: false });

    /* === Motion-speed scaler (no lag) ==========================================
   We always draw the latest frame, but shift the drawn image opposite to
   device rotation so the apparent motion is scaled by `speedFactor`.
   -------------------------------------------------------------------------- */
    const H_FOV_DEG = 60; // Approx phone horizontal field-of-view (tweak per device)
    const V_FOV_DEG = 45; // Approx vertical FOV (tweak per device)
    const ZOOM = 1.2; // Overscan to hide edges while we shift (1.0 .. 1.3 typical)

    let running = false;
    let speedFactor = 0.5; // from slider: 1.0 = normal, 0.5 = half speed
    const rate = document.getElementById("rate");
    const rateVal = document.getElementById("rateVal");
    rate.addEventListener("input", (e) => {
      speedFactor = Number(e.target.value);
      rateVal.textContent = speedFactor.toFixed(2) + "×";
    });

    let pxPerDegX = 0,
      pxPerDegY = 0; // computed after we know video size
    function computePxPerDeg(w, h) {
      // Small-angle model: pixel shift ≈ f * theta(rad), f = (W/2)/tan(FOV/2)
      const fX = w / 2 / Math.tan((H_FOV_DEG * Math.PI) / 180 / 2);
      const fY = h / 2 / Math.tan((V_FOV_DEG * Math.PI) / 180 / 2);
      pxPerDegX = fX * (Math.PI / 180);
      pxPerDegY = fY * (Math.PI / 180);
    }

    /* === Gyro integration ====================================================== */
    let haveMotion = false;
    let yawDeg = 0,
      pitchDeg = 0; // integrated rotation (degrees)
    let lastMotionTS = null;

    function onDeviceMotion(e) {
      // rotationRate is deg/s
      const rr = e.rotationRate || {};
      const now = e.timeStamp || performance.now();
      const dt =
        lastMotionTS == null ? 0 : Math.max(0, (now - lastMotionTS) / 1000);
      lastMotionTS = now;

      // Axes mapping (best-effort; devices vary):
      // alpha: z (twist), beta: x (pitch), gamma: y (roll). For "pan" feel,
      // yaw-ish movement is mostly around Z/Y; vertical tilt is around X.
      const alpha = rr.alpha || 0; // z
      const beta = rr.beta || 0; // x
      const gamma = rr.gamma || 0; // y

      // Integrate. We treat yaw as mostly Z (alpha), pitch as X (beta).
      yawDeg += alpha * dt;
      pitchDeg += beta * dt;

      haveMotion = true;
    }

    let useOrientationFallback = false;
    let prevOri = { alpha: null, beta: null, gamma: null };
    function onDeviceOrientation(e) {
      // Fallback only if gyro not available/denied
      if (!useOrientationFallback) return;
      const { alpha, beta, gamma } = e; // degrees
      const now = e.timeStamp || performance.now();
      if (prevOri.alpha == null) {
        prevOri = { alpha, beta, gamma, t: now };
        return;
      }
      const dt = Math.max(0, (now - prevOri.t) / 1000);
      // Compute small deltas with wrap handling for alpha
      const dAlpha = normDelta(alpha - prevOri.alpha);
      const dBeta = normDelta(beta - prevOri.beta);
      yawDeg += dAlpha;
      pitchDeg += dBeta;
      prevOri = { alpha, beta, gamma, t: now };
    }
    function normDelta(d) {
      // map to [-180, 180]
      if (d > 180) d -= 360;
      else if (d < -180) d += 360;
      return d;
    }

    /* === Drawing (live, no buffering) ========================================= */
    function drawLive() {
      if (!running) return;
      const w = src.videoWidth || 0,
        h = src.videoHeight || 0;
      if (w && h && (canvas.width !== w || canvas.height !== h)) {
        canvas.width = w;
        canvas.height = h;
        computePxPerDeg(w, h);
      }
      if (w && h) {
        // Compensation = (1 - speedFactor) * integrated rotation → pixels
        const compK = 1 - Math.max(0, Math.min(1, speedFactor));
        let offX = -yawDeg * pxPerDegX * compK; // negative to oppose motion
        let offY = -pitchDeg * pxPerDegY * compK;

        // Clamp offsets to zoom margins
        const marginX = (ZOOM - 1) * w * 0.5;
        const marginY = (ZOOM - 1) * h * 0.5;
        if (offX > marginX) offX = marginX;
        if (offX < -marginX) offX = -marginX;
        if (offY > marginY) offY = marginY;
        if (offY < -marginY) offY = -marginY;

        // Draw: overscanned frame shifted by (offX, offY)
        try {
          ctx.setTransform(1, 0, 0, 1, 0, 0); // reset
          ctx.drawImage(
            src,
            -marginX + offX,
            -marginY + offY,
            w * ZOOM,
            h * ZOOM
          );
        } catch {}
      }

      if ("requestVideoFrameCallback" in HTMLVideoElement.prototype) {
        src.requestVideoFrameCallback(() => drawLive());
      } else {
        requestAnimationFrame(drawLive);
      }
    }

    /* === Motion permission flow (iOS) ========================================= */
    async function ensureMotionPermission() {
      // Most Androids: already fine. iOS 13+: needs user gesture.
      if (
        typeof DeviceMotionEvent !== "undefined" &&
        typeof DeviceMotionEvent.requestPermission === "function"
      ) {
        try {
          const res = await DeviceMotionEvent.requestPermission();
          if (res === "granted") {
            window.addEventListener("devicemotion", onDeviceMotion, {
              passive: true,
            });
            haveMotion = true;
            return true;
          }
        } catch {}
        return false;
      } else {
        // No special permission API; try listening directly
        window.addEventListener("devicemotion", onDeviceMotion, {
          passive: true,
        });
        // If nothing arrives, we’ll fallback to orientation
        setTimeout(() => {
          if (!haveMotion) {
            useOrientationFallback = true;
            window.addEventListener(
              "deviceorientation",
              onDeviceOrientation,
              true
            );
          }
        }, 1000);
        return true;
      }
    }

    /* === Startup / lifecycle =================================================== */
    async function startAll() {
      try {
        const stream = await getRearStream();
        src.srcObject = stream;
        await src.play();
        running = true;

        // Motion permission
        const motionOk = await ensureMotionPermission();
        if (!motionOk) {
          // Ask with overlay if blocked
          const overlay = document.getElementById("tapToStart");
          overlay.style.display = "grid";
          overlay.onclick = async () => {
            overlay.textContent = "Enabling motion…";
            const granted = await ensureMotionPermission();
            if (granted) {
              overlay.style.display = "none";
              drawLive();
            } else {
              overlay.textContent = "Motion blocked. Tap to retry.";
            }
          };
        } else {
          const overlay = document.getElementById("tapToStart");
          if (overlay) overlay.style.display = "none";
          drawLive();
        }
      } catch (e) {
        console.error(e);
        const overlay = document.getElementById("tapToStart");
        if (overlay) {
          overlay.style.display = "grid";
          overlay.onclick = () => location.reload();
        } else {
          alert(
            "Camera failed. Ensure HTTPS and allow camera.\n\n" + e.message
          );
        }
      }
    }

    window.addEventListener("load", startAll);

    // Pause/resume
    document.addEventListener("visibilitychange", () => {
      running = !document.hidden;
      if (running) drawLive();
    });

    // Cleanup
    window.addEventListener("beforeunload", () => {
      try {
        const s = src.srcObject;
        if (s) s.getTracks().forEach((t) => t.stop());
      } catch {}
    });
  </script>
</body>
