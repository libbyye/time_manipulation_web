<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<body
  style="
    margin: 0;
    background: #000;
    display: grid;
    place-items: center;
    height: 100dvh;
  "
>
  <video id="src" playsinline muted autoplay style="display: none"></video>
  <canvas
    id="out"
    style="width: 100vw; height: 100vh; object-fit: cover"
  ></canvas>
  <button
    id="start"
    style="
      position: fixed;
      inset: auto 1rem 1rem auto;
      padding: 0.7rem 1rem;
      border-radius: 0.7rem;
    "
  >
    Start front camera (0.5×)
  </button>
  <script>
    const SLOW_FACTOR = 0.5; // 0.5× speed (half as fast)
    const MAX_BUFFER_SECONDS = 12; // cap to avoid huge memory
    const src = document.getElementById("src");
    const canvas = document.getElementById("out");
    const ctx = canvas.getContext("2d", { alpha: false });

    async function start() {
      document.getElementById("start").style.display = "none";
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user" },
        audio: false,
      });
      src.srcObject = stream;
      await src.play();

      // Estimate FPS as we go; start with a sane default
      let fps = 30;
      const frameQueue = [];
      let running = true;

      // Producer: enqueue bitmaps as fast as camera delivers them
      function pump(_, metadata) {
        if (!running) return;
        // Update FPS estimate if metadata is available
        if (metadata && metadata.mediaTime && metadata.presentedFrames) {
          const est = metadata.presentedFrames / metadata.mediaTime;
          if (isFinite(est) && est > 0) fps = Math.max(12, Math.min(60, est));
        }
        // Snapshot current frame into an ImageBitmap (cheap copy for drawing later)
        createImageBitmap(src)
          .then((bmp) => {
            const maxFrames = Math.ceil(MAX_BUFFER_SECONDS * fps);
            if (frameQueue.length >= maxFrames) {
              // Drop oldest to keep memory bounded; this sets an upper bound on lag.
              const old = frameQueue.shift();
              old.close && old.close();
            }
            frameQueue.push(bmp);
            src.requestVideoFrameCallback(pump);
          })
          .catch(() => {
            running = false;
          });
      }
      (
        src.requestVideoFrameCallback ||
        function (cb) {
          // Fallback if rVFC is missing: sample via rAF (~display FPS)
          function loop(t) {
            if (!running) return;
            cb(t, {});
            requestAnimationFrame(loop);
          }
          requestAnimationFrame(loop);
        }
      )(pump);

      // Consumer: draw from the queue at slower-than-capture rate
      (function drawLoop() {
        if (!running) return;
        const bmp = frameQueue.shift();
        if (bmp) {
          if (canvas.width !== bmp.width || canvas.height !== bmp.height) {
            canvas.width = bmp.width;
            canvas.height = bmp.height;
          }
          ctx.drawImage(bmp, 0, 0, canvas.width, canvas.height);
          bmp.close && bmp.close();
        }
        setTimeout(drawLoop, 1000 / (fps * SLOW_FACTOR)); // e.g., play 15 fps if capture ~30
      })();
    }
    document.getElementById("start").addEventListener("click", start);
  </script>
</body>
