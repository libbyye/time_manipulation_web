<!DOCTYPE html>
<html lang="en">
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>Motion-Scaled Camera</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      background: #000;
      color: #fff;
      font-family: system-ui, sans-serif;
    }
    .ui {
      position: fixed;
      inset: auto 0 0 0;
      background: rgba(0, 0, 0, 0.5);
      padding: 12px;
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .wrap {
      position: fixed;
      inset: 0;
      overflow: hidden;
    }
    video {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(1.15); /* overscan */
      will-change: transform;
      min-width: 100%;
      min-height: 100%;
    }
    input[type="range"] {
      width: 40vw;
    }
    button {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #666;
      background: #111;
      color: #fff;
    }
    .val {
      min-width: 3ch;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
  </style>
  <div class="wrap">
    <video id="v" playsinline muted autoplay></video>
  </div>
  <div class="ui">
    <button id="start">Start camera</button>
    <label
      >Motion scale <span class="val" id="sv">1.00</span>
      <input
        id="scale"
        type="range"
        min="0.3"
        max="1.0"
        step="0.01"
        value="1.00"
      />
    </label>
  </div>
  <script>
    (async () => {
      const video = document.getElementById("v");
      const startBtn = document.getElementById("start");
      const slider = document.getElementById("scale");
      const sVal = document.getElementById("sv");

      let baseline = null; // {alpha, beta, gamma}
      let filtered = { yaw: 0, pitch: 0, roll: 0 };
      const smooth = 0.12; // low-pass factor (0..1), higher = snappier
      let scale = 1.0;

      slider.addEventListener("input", () => {
        scale = parseFloat(slider.value);
        sVal.textContent = scale.toFixed(2);
      });

      async function requestMotionPermIfNeeded() {
        const iOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        const permNeeded =
          iOS &&
          typeof DeviceMotionEvent !== "undefined" &&
          typeof DeviceMotionEvent.requestPermission === "function";
        if (permNeeded) {
          try {
            const res = await DeviceMotionEvent.requestPermission();
            if (res !== "granted") throw new Error("Motion permission denied");
          } catch (e) {
            console.warn(e);
          }
        }
      }

      async function start() {
        await requestMotionPermIfNeeded();
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: { ideal: "environment" } },
            audio: false,
          });
          video.srcObject = stream;
          await video.play();
          startBtn.disabled = true;
          startBtn.textContent = "Running";
        } catch (e) {
          alert("Camera error: " + e.message);
          return;
        }

        window.addEventListener("deviceorientation", (ev) => {
          // ev.alpha (z), ev.beta (x), ev.gamma (y) in degrees; may be null on some devices
          if (ev.alpha == null || ev.beta == null || ev.gamma == null) return;
          const a = (ev.alpha * Math.PI) / 180; // yaw-ish
          const b = (ev.beta * Math.PI) / 180; // pitch-ish
          const g = (ev.gamma * Math.PI) / 180; // roll-ish (screen axes)
          if (!baseline) baseline = { a, b, g };

          // deltas from baseline
          const yaw = wrap(a - baseline.a);
          const pitch = b - baseline.b;
          const roll = g - baseline.g;

          // simple low-pass filter
          filtered.yaw += (yaw - filtered.yaw) * smooth;
          filtered.pitch += (pitch - filtered.pitch) * smooth;
          filtered.roll += (roll - filtered.roll) * smooth;
        });

        function wrap(r) {
          // wrap to [-PI, PI]
          const PI = Math.PI;
          return ((r + PI) % (2 * PI)) - PI;
        }

        function render() {
          // compensation factor
          const c = 1 - scale;

          // Map radians to pixels: rough heuristic using ~60° horizontal FOV
          const w = window.innerWidth;
          const h = window.innerHeight;
          const pxPerRadX = w / (Math.PI / 3); // ~60° = PI/3
          const pxPerRadY = h / (Math.PI / 3);

          const tx = -c * filtered.yaw * pxPerRadX; // negative to counter-move
          const ty = c * filtered.pitch * pxPerRadY; // pitch sign feels better positive
          const rZ = -c * filtered.roll;

          video.style.transform = `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px)) rotate(${rZ}rad) scale(1.15)`;
          requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
      }

      startBtn.addEventListener("click", start, { once: true });
    })();
  </script>
</html>
