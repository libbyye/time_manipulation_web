<!DOCTYPE html>
<html lang="en">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Motion-Scaled Camera</title>
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #000;
      color: #fff;
    }
    main {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
      align-items: center;
    }
    .stage {
      position: relative;
      width: 100vw;
      height: calc(100vh - 170px);
      overflow: hidden;
      background: #000;
      border-radius: 16px;
    }
    /* We translate this wrapper in px while the video itself is scaled for “margin” */
    .view {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      will-change: transform;
    }
    video {
      display: block;
      width: 100vw;
      height: calc(100vh - 170px);
      object-fit: cover;
      transform-origin: center center;
      will-change: transform;
    }
    .controls {
      width: 100%;
      max-width: 600px;
      display: grid;
      gap: 8px;
    }
    input[type="range"] {
      width: 100%;
    }
    button {
      padding: 10px 14px;
      border-radius: 10px;
      border: 0;
      background: #1f6feb;
      color: #fff;
      font-weight: 600;
    }
    .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    .hint {
      opacity: 0.7;
      font-size: 0.9rem;
    }
  </style>
  <main>
    <div class="stage" id="stage">
      <div class="view" id="view">
        <video id="cam" autoplay playsinline muted></video>
      </div>
    </div>

    <div class="controls">
      <div class="row">
        <label>Motion scale (k): <strong id="kOut">1.00</strong></label>
        <button id="start">Start</button>
      </div>
      <input
        id="k"
        type="range"
        min="0.30"
        max="1.00"
        step="0.01"
        value="1.00"
      />
      <div class="hint">
        Tip: k=1.00 shows the raw camera. Lower k reduces perceived motion
        (requires extra zoom).
      </div>
      <div id="status" class="hint"></div>
    </div>
  </main>

  <script>
    (async function () {
      const video = document.getElementById("cam");
      const view = document.getElementById("view");
      const stage = document.getElementById("stage");
      const startBtn = document.getElementById("start");
      const kSlider = document.getElementById("k");
      const kOut = document.getElementById("kOut");
      const status = document.getElementById("status");

      let k = parseFloat(kSlider.value); // user scale factor (0.3–1.0)
      let scale = 1.25; // zoom to give us margin for counter-pan
      let baseline = null; // {beta, gamma}
      let pxPerDegX, pxPerDegY; // sensitivity (px per degree)
      let maxX, maxY; // clamps based on zoom & viewport

      function updateMetrics() {
        // map ~45° tilt to near full-width/height of the stage
        pxPerDegX = stage.clientWidth / 45;
        pxPerDegY = stage.clientHeight / 45;
        maxX = ((scale - 1) * stage.clientWidth) / 2;
        maxY = ((scale - 1) * stage.clientHeight) / 2;
        video.style.transform = `scale(${scale})`;
      }
      updateMetrics();
      window.addEventListener("resize", updateMetrics);

      kSlider.addEventListener("input", () => {
        k = parseFloat(kSlider.value);
        kOut.textContent = k.toFixed(2);
      });

      async function startCamera() {
        status.textContent = "Requesting camera...";
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: "environment" } },
          audio: false,
        });
        video.srcObject = stream;
        await video.play();
      }

      async function startMotion() {
        // iOS requires a permission request in a user gesture
        try {
          if (
            window.DeviceOrientationEvent &&
            typeof DeviceOrientationEvent.requestPermission === "function"
          ) {
            const resp = await DeviceOrientationEvent.requestPermission();
            if (resp !== "granted") throw new Error("Motion permission denied");
          }
        } catch (e) {
          // Some browsers don’t implement requestPermission; ignore here
        }

        baseline = null;
        window.addEventListener("deviceorientation", handleOrientation, {
          passive: true,
        });
      }

      function handleOrientation(e) {
        if (e.beta == null || e.gamma == null) return; // not supported
        if (!baseline) baseline = { beta: e.beta, gamma: e.gamma };

        // delta from baseline
        let dBeta = e.beta - baseline.beta; // front-back tilt (up/down)
        let dGamma = e.gamma - baseline.gamma; // left-right tilt (pan)

        // Counter-move the view by (1 - k) * delta
        let offX = -(1 - k) * dGamma * pxPerDegX;
        let offY = (1 - k) * dBeta * pxPerDegY;

        // clamp to avoid exposing edges
        offX = Math.max(-maxX, Math.min(maxX, offX));
        offY = Math.max(-maxY, Math.min(maxY, offY));

        // translate from center, then apply px offset
        view.style.transform = `translate(-50%,-50%) translate(${offX.toFixed(
          1
        )}px, ${offY.toFixed(1)}px)`;
      }

      startBtn.addEventListener("click", async () => {
        startBtn.disabled = true;
        try {
          if (!("mediaDevices" in navigator))
            throw new Error("No mediaDevices API");
          await startCamera();
          await startMotion();
          status.textContent = "Running. Move your phone and adjust k.";
        } catch (err) {
          status.textContent = "Error: " + err.message;
          startBtn.disabled = false;
        }
      });
    })();
  </script>
</html>
